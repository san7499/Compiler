const { exec } = require('child_process');
const fs = require('fs');
const cuid = require('cuid');
const colors = require('colors');
const cppModule = require('./cppModule.js');
const javaModule = require('./javaModule.js');
const pyModule = require('./pyModule.js');
const csModule = require('./csModule.js');
const vbModule = require('./vbModule.js');
const path = require('path');

exports.stats = false;

exports.init = function (option) {
    if (option && option.stats === true) {
        console.log('Statistics for compilex is On'.green);
        exports.stats = true;
    }
    if (!fs.existsSync('./temp')) {
        if (exports.stats) {
            console.log('INFO: '.cyan + 'temp directory created for storing temporary files.'.cyan);
        }
        fs.mkdirSync('./temp');
    }
};

exports.compileCPP = function (envData, code, fn) {
    if (exports.stats) cppModule.stats = true;
    cppModule.compileCPP(envData, code, fn);
};

exports.compileCPPWithInput = function (envData, code, input, fn) {
    if (exports.stats) cppModule.stats = true;
    cppModule.compileCPPWithInput(envData, code, input, fn);
};

exports.compileJava = function (envData, code, fn) {
    if (exports.stats) javaModule.stats = true;
    javaModule.compileJava(envData, code, fn);
};

exports.compileJavaWithInput = function (envData, code, input, fn) {
    if (exports.stats) javaModule.stats = true;
    javaModule.compileJavaWithInput(envData, code, input, fn);
};

exports.compilePython = function (envData, code, fn) {
    if (exports.stats) pyModule.stats = true;
    pyModule.compilePython(envData, code, fn);
};

exports.compilePythonWithInput = function (envData, code, input, fn) {
    if (exports.stats) pyModule.stats = true;
    pyModule.compilePythonWithInput(envData, code, input, fn);
};

exports.compileCS = function (envData, code, fn) {
    if (exports.stats) csModule.stats = true;
    csModule.compileCS(envData, code, fn);
};

exports.compileCSWithInput = function (envData, code, input, fn) {
    if (exports.stats) csModule.stats = true;
    csModule.compileCSWithInput(envData, code, input, fn);
};

exports.compileVB = function (envData, code, fn) {
    if (exports.stats) vbModule.stats = true;
    vbModule.compileVB(envData, code, fn);
};

exports.compileVBWithInput = function (envData, code, input, fn) {
    if (exports.stats) vbModule.stats = true;
    vbModule.compileVBWithInput(envData, code, input, fn);
};

exports.flushSync = function () {
    const tempPath = './temp';
    if (fs.existsSync(tempPath)) {
        const files = fs.readdirSync(tempPath);
        files.forEach(file => {
            fs.unlinkSync(path.join(tempPath, file));
        });
    }
};

exports.flush = function (fn) {
    const tempPath = './temp';
    fs.readdir(tempPath, (err, files) => {
        if (err) throw err;
        files.forEach(file => {
            fs.rm(path.join(tempPath, file), { recursive: true }, err => {
                if (err) throw err;
            });
        });
        if (fn) fn();
    });
};

exports.fullStat = function (fn) {
    const uptime = process.uptime();
    let cppCount = 0;
    let javaCount = 0;
    let pyCount = 0;

    const files = fs.readdirSync('./temp');
    files.forEach(file => {
        const stat = fs.statSync(path.join('./temp', file));
        if (stat.isFile()) {
            if (file.endsWith('.cpp')) cppCount++;
            if (file.endsWith('.py')) pyCount++;
        } else {
            javaCount++;
        }
    });

    const jsonData = {
        serverUptime: uptime,
        fileDetails: {
            cpp: cppCount,
            java: javaCount,
            python: pyCount
        }
    };

    if (exports.stats) {
        const statsString = `Server Statistics`.yellow + "\n" +
            `compilex Server Uptime: ${uptime}\n` +
            `Files on storage:\n` +
            `C & CPP files: ${cppCount}\n` +
            `Java files: ${javaCount}\n` +
            `Python files: ${pyCount}`;
        console.log(statsString);
    }
    fn(jsonData);
};
